indent = (str) ->
  ("  #{line}" for line in str.split("\n")).join("\n")

exports.QueryPlan = class QueryPlan
    constructor: (@query) ->

exports.Select = class Select
    constructor: (@fields, @source, @distinct=false, @joins=[], @unions=[]) ->
      @order = null
      @group = null
      @where = null
      @limit = null
    toString: ->
      ret = ["SELECT #{@fields.join(', ')}"] 
      ret.push indent("FROM #{@source}")
      ret.push indent(join.toString()) for join in @joins
      ret.push indent(@where.toString()) if @where
      ret.push indent(@group.toString()) if @group
      ret.push indent(@order.toString()) if @order
      ret.push indent(@limit.toString()) if @limit
      ret.push union.toString() for union in @unions
      ret.join("\n")

exports.Insert = class Insert
    constructor: (@target, @insertExpression, @fields) ->
    toString: ->
      ret = ""

exports.Delete = class Delete
    constructor: (@target, @deleteCondition) ->
    toString: ->
      ret = ""

exports.Update = class Update
    constructor: (@target, @assignList, @updateCondition) ->
    toString: ->
      ret = ""

exports.CreateTable = class CreateTable
    constructor: (@target, @fieldDef, @ifNotExists = false) ->
    toString: ->
      ret = ""

exports.DropTable = class DropTable
    constructor: (@target, @ifExists = false) ->
      @isDrop = true
    toString: ->
      ret = ""

exports.AlterTable = class AlterTable
    constructor: (@target, @newName) ->
    toString: ->
      ret = ""
      
#for derived tables; i.e, expressions whose results are tables and can be used with relational operators
exports.SubSelect = class SubSelect
  constructor: (@select, @name=null) ->
  toString: -> 
    ret = []
    ret.push '('
    ret.push indent(@select.toString())
    ret.push if @name then ") #{@name.toString()}" else ")"
    ret.join("\n")

#for expressions whose results are not necessary tables (usually scalars) and can not be used with relational operators;
exports.SubQuery = class SubQuery
    constructor: (@select) ->
      @fields = @select.fields
      @source = @select.source
      @distinct = @select.distinct
      @joins = @select.joins
      @unions = @select.unions
      @group = @select.group
      @where = @select.where
      delete @select
    toString: ->
      ret = ["SELECT #{@fields.join(', ')}"] 
      ret.push indent("FROM #{@source}")
      ret.push indent(join.toString()) for join in @joins
      ret.push indent(@where.toString()) if @where
      ret.push indent(@group.toString()) if @group
      ret.push union.toString() for union in @unions
      ret.join("\n")

exports.Join = class Join
  constructor: (@right, @conditions=null, @side=null, @mode='INNER') ->
  toString: -> 
    ret = ''
    ret += "#{@side} " if @side?
    ret += "#{@mode} " if @mode?
    ret + "JOIN #{@right}\n" + indent("ON #{@conditions}")

exports.Union = class Union
  constructor: (@query, @all=false) ->
  toString: -> 
    all = if @all then ' ALL' else ''
    "UNION#{all}\n#{@query.toString()}"

exports.LiteralValue = class LiteralValue
  constructor: (@value, @value2=null) -> 
    if @value2
      @nested = true
      @values = @value.values
      @values.push(value2)
    else
      @nested = false
      @values = [@value]
  toString: -> "#{@values.join('.')}"

exports.StringValue = class StringValue
  constructor: (@value, @quoteType="''") ->
  toString: -> "#{@quoteType}#{@value}#{@quoteType}"

exports.NumberValue = class NumberValue
  constructor: (@value, @sign='+') ->
    @value = switch sign
      when '-'
        Number(value) * -1
      else
        Number(value)
  toString: -> if @value < 0 then '-'+@value.toString() else @value.toString()

exports.BooleanValue = class BooleanValue
  constructor: (value) -> 
    @value = switch value.toLowerCase()
      when 'true'
        true
      when 'false'
        false
      else
        null
  toString: -> if @value? then @value.toString().toUpperCase() else 'NULL'

exports.FunctionValue = class FunctionValue	
  constructor: (@name, @arguments=[], @udf=false, isDistinct) ->
    _name = name.toLowerCase()
    throw new Error("Parser Error -- only count function should have distinct.") if not (_name is "count" or _name is "avg") and isDistinct is true
    @arguments[1] = isDistinct  if _name is "count" or _name is "avg"

  toString: -> "#{@name}(#{@arguments.join(', ')})"

exports.FunctionCastValue = class FunctionCastValue
  constructor: (@name, @expression, @toType) ->
  toString: -> "#{@name}(#{@expression} AS #{@toType})"

exports.Order = class Order
  constructor: (@orderings) ->
  toString: -> "ORDER BY #{@orderings.join(', ')}"

exports.OrderArgument = class OrderArgument
  constructor: (@value, @direction='ASC', @collation="") ->
  toString: -> "#{@value} #{@collation} #{@direction}"

exports.Limit = class Limit
  constructor: (@pageNo=null, @numRows) ->
  toString: ->
    if @pageNo
        "LIMIT #{@numRows}"
    else
        "LIMIT #{@pageNo}, #{@numRows}"

exports.Table = class Table
  constructor: (@name, @win=null, @winFn=null, @winArg=null) ->
  toString: -> 
    if @win
      "#{@name}.#{@win}:#{@winFn}(#{@winArg})"
    else
      @name.toString()

exports.Group = class Group
  constructor: (@fields) ->
    @having = null
  toString: -> 
    ret = ["GROUP BY #{@fields.join(', ')}"]
    ret.push @having.toString() if @having
    ret.join("\n")

exports.Where = class Where
  constructor: (@conditions) ->
  toString: -> "WHERE #{@conditions}"

exports.Having = class Having
  constructor: (@conditions) ->
  toString: -> "HAVING #{@conditions}"

exports.Op = class Op
  constructor: (@operation, @left, @right) ->
  toString: -> "(#{@left} #{@operation} #{@right})"

exports.Field = class Field
  constructor: (@field, @name=null) ->
  toString: -> if @name then "#{@field} AS #{@name}" else @field.toString()

exports.FieldDef = class FieldDef
  constructor: (@field, @type, @isNullable, @isPK, @isAutoInc) ->
  toString: -> ""
  
exports.Star = class Star
  constructor: (@literal) ->
    @star = true
  toString: -> "#{@literal}*"
      